1
00:00:07,000 --> 00:00:11,000


2
00:00:07,000 --> 00:00:11,000
So, the topic today is dynamic
programming.

3
00:00:11,000 --> 00:00:21,000


4
00:00:21,000 --> 00:00:25,000
The term programming in the
name of this term doesn't refer

5
00:00:25,000 --> 00:00:30,000
to computer programming.
OK, programming is an old word

6
00:00:30,000 --> 00:00:35,000
that means any tabular method
for accomplishing something.

7
00:00:35,000 --> 00:00:39,000
So, you'll hear about linear
programming and dynamic

8
00:00:39,000 --> 00:00:42,000
programming.
Either of those,

9
00:00:42,000 --> 00:00:47,000
even though we now incorporate
those algorithms in computer

10
00:00:47,000 --> 00:00:52,000
programs, originally computer
programming, you were given a

11
00:00:52,000 --> 00:00:57,000
datasheet and you put one line
per line of code as a tabular

12
00:00:57,000 --> 00:01:04,000
method for giving the machine
instructions as to what to do.

13
00:01:04,000 --> 00:01:07,000
OK, so the term programming is
older.

14
00:01:07,000 --> 00:01:11,000
Of course, and now
conventionally when you see

15
00:01:11,000 --> 00:01:15,000
programming, you mean software,
computer programming.

16
00:01:15,000 --> 00:01:18,000
But that wasn't always the
case.

17
00:01:18,000 --> 00:01:22,000
And these terms continue in the
literature.

18
00:01:22,000 --> 00:01:26,000
So, dynamic programming is a
design technique like other

19
00:01:26,000 --> 00:01:33,000
design techniques we've seen
such as divided and conquer.

20
00:01:33,000 --> 00:01:40,000
OK, so it's a way of solving a
class of problems rather than a

21
00:01:40,000 --> 00:01:43,000
particular algorithm or
something.

22
00:01:43,000 --> 00:01:50,000
So, we're going to work through
this for the example of

23
00:01:50,000 --> 00:01:55,000
so-called longest common
subsequence problem,

24
00:01:55,000 --> 00:02:00,000
sometimes called LCS,
OK, which is a problem that

25
00:02:00,000 --> 00:02:06,000
comes up in a variety of
contexts.

26
00:02:06,000 --> 00:02:10,000
And it's particularly important
in computational biology,

27
00:02:10,000 --> 00:02:14,000
where you have long DNA
strains, and you're trying to

28
00:02:14,000 --> 00:02:19,000
find commonalities between two
strings, OK, one which may be a

29
00:02:19,000 --> 00:02:23,000
genome, and one may be various,
when people do,

30
00:02:23,000 --> 00:02:28,000
what is that thing called when
they do the evolutionary

31
00:02:28,000 --> 00:02:31,000
comparisons?
The evolutionary trees,

32
00:02:31,000 --> 00:02:33,000
yeah, right,
yeah, exactly,

33
00:02:33,000 --> 00:02:35,000
phylogenetic trees,
there you go,

34
00:02:35,000 --> 00:02:44,000
OK, phylogenetic trees.
Good, so here's the problem.

35
00:02:44,000 --> 00:02:54,000
So, you're given two sequences,
x going from one to m,

36
00:02:54,000 --> 00:03:04,000
and y running from one to n.
You want to find a longest

37
00:03:04,000 --> 00:03:12,000
sequence common to both.
OK, and here I say a,

38
00:03:12,000 --> 00:03:19,000
not the, although it's common
to talk about the longest common

39
00:03:19,000 --> 00:03:24,000
subsequence.
Usually the longest comment

40
00:03:24,000 --> 00:03:29,000
subsequence isn't unique.
There could be several

41
00:03:29,000 --> 00:03:35,000
different subsequences that tie
for that.

42
00:03:35,000 --> 00:03:41,000
However, people tend to,
it's one of the sloppinesses

43
00:03:41,000 --> 00:03:45,000
that people will say.
I will try to say a,

44
00:03:45,000 --> 00:03:51,000
unless it's unique.
But I may slip as well because

45
00:03:51,000 --> 00:03:57,000
it's just such a common thing to
just talk about the,

46
00:03:57,000 --> 00:04:02,000
even though there might be
multiple.

47
00:04:02,000 --> 00:04:07,000
So, here's an example.
Suppose x is this sequence,

48
00:04:07,000 --> 00:04:14,000
and y is this sequence.
So, what is a longest common

49
00:04:14,000 --> 00:04:16,000
subsequence of those two
sequences?

50
00:04:16,000 --> 00:04:19,000
See if you can just eyeball it.

51
00:04:19,000 --> 00:04:35,000


52
00:04:35,000 --> 00:04:45,000
AB: length two?
Anybody have one longer?

53
00:04:45,000 --> 00:04:51,000
Excuse me?
BDB, BDB.

54
00:04:51,000 --> 00:05:02,000
BDAB, BDAB, BDAB,
anything longer?

55
00:05:02,000 --> 00:05:09,000
So, BDAB: that's the longest
one.

56
00:05:09,000 --> 00:05:20,000
Is there another one that's the
same length?

57
00:05:20,000 --> 00:05:35,000
Is there another one that ties?
BCAB, BCAB, another one?

58
00:05:35,000 --> 00:05:40,000
BCBA, yeah, there are a bunch
of them all of length four.

59
00:05:40,000 --> 00:05:45,000
There isn't one of length five.
OK, we are actually going to

60
00:05:45,000 --> 00:05:49,000
come up with an algorithm that,
if it's correct,

61
00:05:49,000 --> 00:05:54,000
we're going to show it's
correct, guarantees that there

62
00:05:54,000 --> 00:05:58,000
isn't one of length five.
So all those are,

63
00:05:58,000 --> 00:06:03,000
we can say, any one of these is
the longest comment subsequence

64
00:06:03,000 --> 00:06:06,000
of x and y.
We tend to use it this way

65
00:06:06,000 --> 00:06:11,000
using functional notation,
but it's not a function that's

66
00:06:11,000 --> 00:06:17,000
really a relation.
So, we'll say something is an

67
00:06:17,000 --> 00:06:20,000
LCS when really we only mean
it's an element,

68
00:06:20,000 --> 00:06:23,000
if you will,
of the set of longest common

69
00:06:23,000 --> 00:06:26,000
subsequences.
Once again, it's classic

70
00:06:26,000 --> 00:06:29,000
abusive notation.
As long as we know what we

71
00:06:29,000 --> 00:06:35,000
mean, it's OK to abuse notation.
What we can't do is misuse it.

72
00:06:35,000 --> 00:06:40,000
But abuse, yeah!
Make it so it's easy to deal

73
00:06:40,000 --> 00:06:43,000
with.
But you have to know what's

74
00:06:43,000 --> 00:06:47,000
going on underneath.
OK, so let's see,

75
00:06:47,000 --> 00:06:53,000
so there's a fairly simple
brute force algorithm for

76
00:06:53,000 --> 00:06:59,000
solving this problem.
And that is,

77
00:06:59,000 --> 00:07:10,000
let's just check every,
maybe some of you did this in

78
00:07:10,000 --> 00:07:22,000
your heads, subsequence of x
from one to m to see if it's

79
00:07:22,000 --> 00:07:31,000
also a subsequence of y of one
to n.

80
00:07:31,000 --> 00:07:36,000
So, just take every subsequence
that you can get here,

81
00:07:36,000 --> 00:07:40,000
check it to see if it's in
there.

82
00:07:40,000 --> 00:07:43,000
So let's analyze that.

83
00:07:43,000 --> 00:07:52,000


84
00:07:52,000 --> 00:07:58,000
So, to check,
so if I give you a subsequence

85
00:07:58,000 --> 00:08:05,000
of x, how long does it take you
to check whether it is,

86
00:08:05,000 --> 00:08:14,000
in fact, a subsequence of y?
So, I give you something like

87
00:08:14,000 --> 00:08:18,000
BCAB.
How long does it take me to

88
00:08:18,000 --> 00:08:24,000
check to see if it's a
subsequence of y?

89
00:08:24,000 --> 00:08:28,000
Length of y,
which is order n.

90
00:08:28,000 --> 00:08:34,000
And how do you do it?
Yeah, you just scan.

91
00:08:34,000 --> 00:08:39,000
So as you hit the first
character that matches,

92
00:08:39,000 --> 00:08:41,000
great.
Now, if you will,

93
00:08:41,000 --> 00:08:46,000
recursively see whether the
suffix of your string matches

94
00:08:46,000 --> 00:08:50,000
the suffix of x.
OK, and so, you are just simply

95
00:08:50,000 --> 00:08:54,000
walking down the tree to see if
it matches.

96
00:08:54,000 --> 00:08:59,000
You're walking down the string
to see if it matches.

97
00:08:59,000 --> 00:09:04,000
OK, then the second thing is,
then how many subsequences of x

98
00:09:04,000 --> 00:09:08,000
are there?
Two to the n?

99
00:09:08,000 --> 00:09:15,000
x just goes from one to m,
two to the m subsequences of x,

100
00:09:15,000 --> 00:09:20,000
OK, two to the m.
Two to the m subsequences of x,

101
00:09:20,000 --> 00:09:25,000
OK, one way to see that,
you say, well,

102
00:09:25,000 --> 00:09:32,000
how many subsequences are there
of something there?

103
00:09:32,000 --> 00:09:35,000
If I consider a bit vector of
length m, OK,

104
00:09:35,000 --> 00:09:39,000
that's one or zero,
just every position where

105
00:09:39,000 --> 00:09:42,000
there's a one,
I take out, that identifies an

106
00:09:42,000 --> 00:09:45,000
element that I'm going to take
out.

107
00:09:45,000 --> 00:09:50,000
OK, then that gives me a
mapping from each subsequence of

108
00:09:50,000 --> 00:09:55,000
x, from each bit vector to a
different subsequence of x.

109
00:09:55,000 --> 00:09:58,000
Now, of course,
you could have matching

110
00:09:58,000 --> 00:10:01,000
characters there,
that in the worst case,

111
00:10:01,000 --> 00:10:06,000
all of the characters are
different.

112
00:10:06,000 --> 00:10:14,000
OK, and so every one of those
will be a unique subsequence.

113
00:10:14,000 --> 00:10:22,000
So, each bit vector of length m
corresponds to a subsequence.

114
00:10:22,000 --> 00:10:29,000
That's a generally good trick
to know.

115
00:10:29,000 --> 00:10:38,000
So, the worst-case running time
of this method is order n times

116
00:10:38,000 --> 00:10:43,000
two to the m,
which is, since m is in the

117
00:10:43,000 --> 00:10:52,000
exponent, is exponential time.
And there's a technical term

118
00:10:52,000 --> 00:10:59,000
that we use when something is
exponential time.

119
00:10:59,000 --> 00:11:03,000
Slow: good.
OK, very good.

120
00:11:03,000 --> 00:11:06,000
OK, slow, OK,
so this is really bad.

121
00:11:06,000 --> 00:11:12,000
This is taking a long time to
crank out how long the longest

122
00:11:12,000 --> 00:11:17,000
common subsequence is because
there's so many subsequences.

123
00:11:17,000 --> 00:11:23,000
OK, so we're going to now go
through a process of developing

124
00:11:23,000 --> 00:11:27,000
a far more efficient algorithm
for this problem.

125
00:11:27,000 --> 00:11:34,000
OK, and we're actually going to
go through several stages.

126
00:11:34,000 --> 00:11:42,000
The first one is to go through
simplification stage.

127
00:11:42,000 --> 00:11:52,000
OK, and what we're going to do
is look at simply the length of

128
00:11:52,000 --> 00:11:59,000
the longest common sequence of x
and y.

129
00:11:59,000 --> 00:12:03,000
And then what we'll do is
extend the algorithm to find the

130
00:12:03,000 --> 00:12:06,000
longest common subsequence
itself.

131
00:12:06,000 --> 00:12:10,000
OK, so we're going to look at
the length.

132
00:12:10,000 --> 00:12:13,000
So, simplify the problem,
if you will,

133
00:12:13,000 --> 00:12:16,000
to just try to compute the
length.

134
00:12:16,000 --> 00:12:19,000
What's nice is the length is
unique.

135
00:12:19,000 --> 00:12:23,000
OK, there's only going to be
one length that's going to be

136
00:12:23,000 --> 00:12:27,000
the longest.
OK, and what we'll do is just

137
00:12:27,000 --> 00:12:31,000
focus on the problem of
computing the length.

138
00:12:31,000 --> 00:12:36,000
And then we'll do is we can
back up from that and figure out

139
00:12:36,000 --> 00:12:43,000
what actually is the subsequence
that realizes that length.

140
00:12:43,000 --> 00:12:46,000
OK, and that will be a big
simplification because we don't

141
00:12:46,000 --> 00:12:50,000
have to keep track of a lot of
different possibilities at every

142
00:12:50,000 --> 00:12:52,000
stage.
We just have to keep track of

143
00:12:52,000 --> 00:12:54,000
the one number,
which is the length.

144
00:12:54,000 --> 00:12:57,000
So, it's sort of reduces it to
a numerical problem.

145
00:12:57,000 --> 00:13:00,000
We'll adopt the following
notation.

146
00:13:00,000 --> 00:13:04,000
It's pretty standard notation,
but I just want,

147
00:13:04,000 --> 00:13:09,000
if I put absolute values around
the string or a sequence,

148
00:13:09,000 --> 00:13:13,000
it denotes the length of the
sequence, S.

149
00:13:13,000 --> 00:13:19,000
OK, so that's the first thing.
The second thing we're going to

150
00:13:19,000 --> 00:13:22,000
do is, actually,
we're going to,

151
00:13:22,000 --> 00:13:28,000
which takes a lot more insight
when you come up with a problem

152
00:13:28,000 --> 00:13:33,000
like this,
and in some sense,

153
00:13:33,000 --> 00:13:39,000
ends up being the hardest part
of designing a good dynamic

154
00:13:39,000 --> 00:13:47,000
programming algorithm from any
problem, which is we're going to

155
00:13:47,000 --> 00:13:53,000
actually look not at all
subsequences of x and y,

156
00:13:53,000 --> 00:13:56,000
but just prefixes.

157
00:13:56,000 --> 00:14:06,000


158
00:14:06,000 --> 00:14:13,000
OK, we're just going to look at
prefixes and we're going to show

159
00:14:13,000 --> 00:14:20,000
how we can express the length of
the longest common subsequence

160
00:14:20,000 --> 00:14:24,000
of prefixes in terms of each
other.

161
00:14:24,000 --> 00:14:28,000
In particular,
we're going to define c of ij

162
00:14:28,000 --> 00:14:34,000
to be the length,
the longest common subsequence

163
00:14:34,000 --> 00:14:41,000
of the prefix of x going from
one to i, and y of going to one

164
00:14:41,000 --> 00:14:48,000
to j.
And what we are going to do is

165
00:14:48,000 --> 00:14:56,000
we're going to calculate c[i,j]
for all ij.

166
00:14:56,000 --> 00:15:04,000
And if we do that,
how then do we solve the

167
00:15:04,000 --> 00:15:15,000
problem of the longest common of
sequence of x and y?

168
00:15:15,000 --> 00:15:19,000
How do we solve the longest
common subsequence?

169
00:15:19,000 --> 00:15:23,000
Suppose we've solved this for
all I and j.

170
00:15:23,000 --> 00:15:29,000
How then do we compute the
length of the longest common

171
00:15:29,000 --> 00:15:33,000
subsequence of x and y?
Yeah, c[m,n],

172
00:15:33,000 --> 00:15:37,000
that's all, OK?
So then, c of m,

173
00:15:37,000 --> 00:15:44,000
n is just equal to the longest
common subsequence of x and y,

174
00:15:44,000 --> 00:15:50,000
because if I go from one to n,
I'm done, OK?

175
00:15:50,000 --> 00:15:56,000
And so, it's going to turn out
that what we want to do is

176
00:15:56,000 --> 00:16:02,000
figure out how to express to
c[m,n], in general,

177
00:16:02,000 --> 00:16:08,000
c[i,j], in terms of other
c[i,j].

178
00:16:08,000 --> 00:16:18,000
So, let's see how we do that.
OK, so our theorem is going to

179
00:16:18,000 --> 00:16:23,000
say that c[i,j] is just --

180
00:16:23,000 --> 00:17:05,000


181
00:17:05,000 --> 00:17:10,000
OK, it says that if the i'th
character matches the j'th

182
00:17:10,000 --> 00:17:17,000
character, then i'th character
of x matches the j'th character

183
00:17:17,000 --> 00:17:23,000
of y, then c of ij is just c of
I minus one, j minus one plus

184
00:17:23,000 --> 00:17:26,000
one.
And if they don't match,

185
00:17:26,000 --> 00:17:31,000
then it's either going to be
the longer of c[i,

186
00:17:31,000 --> 00:17:35,000
j-1], and c[i-1,
j], OK?

187
00:17:35,000 --> 00:17:38,000
So that's what we're going to
prove.

188
00:17:38,000 --> 00:17:44,000
And that's going to give us a
way of relating the calculation

189
00:17:44,000 --> 00:17:49,000
of a given c[i,j] to values that
are strictly smaller,

190
00:17:49,000 --> 00:17:56,000
OK, that is at least one of the
arguments is smaller of the two

191
00:17:56,000 --> 00:18:00,000
arguments.
OK, and that's going to give us

192
00:18:00,000 --> 00:18:05,000
a way of being able,
then, to understand how to

193
00:18:05,000 --> 00:18:11,000
calculate c[i,j].
So, let's prove this theorem.

194
00:18:11,000 --> 00:18:18,000
So, we'll start with a case
x[i] equals y of j.

195
00:18:18,000 --> 00:18:22,000
And so, let's draw a picture
here.

196
00:18:22,000 --> 00:18:26,000
So, we have x here.

197
00:18:26,000 --> 00:18:50,000


198
00:18:50,000 --> 00:18:52,000
And here is y.

199
00:18:52,000 --> 00:19:13,000


200
00:19:13,000 --> 00:19:19,000
OK, so here's my sequence,
x, which I'm sort of drawing as

201
00:19:19,000 --> 00:19:25,000
this elongated box,
sequence y, and I'm saying that

202
00:19:25,000 --> 00:19:30,000
x[i] and y[j],
those are equal.

203
00:19:30,000 --> 00:19:38,000


204
00:19:38,000 --> 00:19:46,000
OK, so let's see what that
means.

205
00:19:46,000 --> 00:20:01,000
OK, so let's let z of one to k
be, in fact, the longest common

206
00:20:01,000 --> 00:20:12,000
subsequence of x of one to i,
y of one to j,

207
00:20:12,000 --> 00:20:23,000
where c of ij is equal to k.
OK, so the longest common

208
00:20:23,000 --> 00:20:29,000
subsequence of x and y of one to
I and y of one to j has some

209
00:20:29,000 --> 00:20:32,000
value.
Let's call it k.

210
00:20:32,000 --> 00:20:39,000
And so, let's say that we have
some sequence which realizes

211
00:20:39,000 --> 00:20:42,000
that.
OK, we'll call it z.

212
00:20:42,000 --> 00:20:48,000
OK, so then,
can somebody tell me what z of

213
00:20:48,000 --> 00:20:50,000
k is?

214
00:20:50,000 --> 00:21:04,000


215
00:21:04,000 --> 00:21:05,000
What is z of k here?

216
00:21:05,000 --> 00:21:14,000


217
00:21:14,000 --> 00:21:18,000
Yeah, it's actually equal to x
of I, which is also equal to y

218
00:21:18,000 --> 00:21:19,000
of j?
Why is that?

219
00:21:19,000 --> 00:21:23,000
Why couldn't it be some other
value?

220
00:21:23,000 --> 00:21:41,000


221
00:21:41,000 --> 00:21:43,000
Yeah, so you got the right
idea.

222
00:21:43,000 --> 00:21:46,000
So, the idea is,
suppose that the sequence

223
00:21:46,000 --> 00:21:50,000
didn't include this element here
at the last element,

224
00:21:50,000 --> 00:21:55,000
the longest common subsequence.
OK, so then it includes a bunch

225
00:21:55,000 --> 00:21:59,000
of values in here,
and a bunch of values in here,

226
00:21:59,000 --> 00:22:03,000
same values.
It doesn't include this or

227
00:22:03,000 --> 00:22:07,000
this.
Well, then I could just tack on

228
00:22:07,000 --> 00:22:13,000
this extra character and make it
be longer, make it k plus one

229
00:22:13,000 --> 00:22:18,000
because these two match.
OK, so if the sequence ended

230
00:22:18,000 --> 00:22:20,000
before --

231
00:22:20,000 --> 00:22:34,000


232
00:22:34,000 --> 00:22:40,000
-- just extend it by tacking on
x[i].

233
00:22:40,000 --> 00:22:48,000
OK, it would be fairly simple
to just tack on x[i].

234
00:22:48,000 --> 00:22:58,000
OK, so if that's the case,
then if I look at z going one

235
00:22:58,000 --> 00:23:05,000
up to k minus one,
that's certainly a common

236
00:23:05,000 --> 00:23:14,000
sequence of x of 1 up to,
excuse me, of up to i minus

237
00:23:14,000 --> 00:23:20,000
one.
And, y of one up to j minus

238
00:23:20,000 --> 00:23:26,000
one, OK, because this is a
longest common sequence.

239
00:23:26,000 --> 00:23:33,000
z is a longest common sequence
is, from x of one to i,

240
00:23:33,000 --> 00:23:38,000
y of one to j.
And, we know what the last

241
00:23:38,000 --> 00:23:41,000
character is.
It's just x[i],

242
00:23:41,000 --> 00:23:43,000
or equivalently,
y[j].

243
00:23:43,000 --> 00:23:47,000
So therefore,
everything except the last

244
00:23:47,000 --> 00:23:53,000
character must at least be a
common sequence of x of one to i

245
00:23:53,000 --> 00:23:57,000
minus one, y of one to j minus
one.

246
00:23:57,000 --> 00:24:04,000
Everybody with me?
It must be a comment sequence.

247
00:24:04,000 --> 00:24:12,000
OK, now, what you also suspect?
What do you also suspect about

248
00:24:12,000 --> 00:24:18,000
z of one to k?
It's a common sequence of these

249
00:24:18,000 --> 00:24:19,000
two.
Yeah?

250
00:24:19,000 --> 00:24:26,000
Yeah, it's a longest common
sequence.

251
00:24:26,000 --> 00:24:34,000
So that's what we claim,
z of one up to k minus one is

252
00:24:34,000 --> 00:24:42,000
in fact a longest common
subsequence of x of one to i

253
00:24:42,000 --> 00:24:48,000
minus one, and y of one to j
minus one, OK?

254
00:24:48,000 --> 00:24:57,000
So, let's prove that claim.
So, we'll just have a little

255
00:24:57,000 --> 00:25:09,000
diversion to prove the claim.
OK, so suppose that w is a

256
00:25:09,000 --> 00:25:21,000
longer comment sequence,
that is, that the length,

257
00:25:21,000 --> 00:25:30,000
the w, is bigger than k minus
one.

258
00:25:30,000 --> 00:25:35,000
OK, so suppose we have a longer
comment sequence than z of one

259
00:25:35,000 --> 00:25:38,000
to k minus one.
So, it's got to have length

260
00:25:38,000 --> 00:25:42,000
that's bigger than k minus one
if it's longer.

261
00:25:42,000 --> 00:25:47,000
OK, and now what we do is we
use a classic argument you're

262
00:25:47,000 --> 00:25:51,000
going to see multiple times,
not just this week,

263
00:25:51,000 --> 00:25:56,000
which it will be important for
this week, but through several

264
00:25:56,000 --> 00:25:59,000
lectures.
Hence, it's called a cut and

265
00:25:59,000 --> 00:26:06,000
paste argument.
So, the idea is let's take a

266
00:26:06,000 --> 00:26:15,000
look at w, concatenate it with
that last character,

267
00:26:15,000 --> 00:26:19,000
z of k.
so, this is string,

268
00:26:19,000 --> 00:26:27,000
OK, so that's just my
terminology for string

269
00:26:27,000 --> 00:26:36,000
concatenation.
OK, so I take whatever I

270
00:26:36,000 --> 00:26:48,000
claimed was a longer comment
subsequence, and I concatenate z

271
00:26:48,000 --> 00:26:56,000
of k to it.
OK, so that is certainly a

272
00:26:56,000 --> 00:27:11,000
common sequence of x of one to I
minus one, and y of one to j.

273
00:27:11,000 --> 00:27:18,000
And it has length bigger than k
because it's basically,

274
00:27:18,000 --> 00:27:24,000
what is its length?
The length of w is bigger than

275
00:27:24,000 --> 00:27:28,000
k minus one.
I add one character.

276
00:27:28,000 --> 00:27:37,000
So, this combination here,
now, has length bigger that k.

277
00:27:37,000 --> 00:27:43,000
OK, and that's a contradiction,
thereby proving the claim.

278
00:27:43,000 --> 00:27:47,000
So, I'm simply saying,
I claim this.

279
00:27:47,000 --> 00:27:52,000
Suppose you have a longer one.
Well, let me show,

280
00:27:52,000 --> 00:27:58,000
if I had a longer common
sequence for the prefixes where

281
00:27:58,000 --> 00:28:05,000
we dropped the character from
both strings if it was longer

282
00:28:05,000 --> 00:28:12,000
there, but we would have made
the whole thing longer.

283
00:28:12,000 --> 00:28:16,000
So that can't be.
So, therefore,

284
00:28:16,000 --> 00:28:22,000
this must be a longest common
subsequence, OK?

285
00:28:22,000 --> 00:28:27,000
Questions?
Because you are going to need

286
00:28:27,000 --> 00:28:33,000
to be able to do this kind of
proof ad nauseam,

287
00:28:33,000 --> 00:28:39,000
almost.
So, if there any questions,

288
00:28:39,000 --> 00:28:42,000
let them at me,
people.

289
00:28:42,000 --> 00:28:47,000
OK, so now what we have
established is that z one

290
00:28:47,000 --> 00:28:55,000
through k is a longest common
subsequence of the two prefixes

291
00:28:55,000 --> 00:29:05,000
when we drop the last character.
So, thus, we have c of i minus

292
00:29:05,000 --> 00:29:11,000
one, j minus one is equal to
what?

293
00:29:11,000 --> 00:29:19,000
What's c of i minus one,
j minus one?

294
00:29:19,000 --> 00:29:31,000


295
00:29:31,000 --> 00:29:33,000
k minus one;
thank you.

296
00:29:33,000 --> 00:29:40,000
Let's move on with the class,
right, OK, which implies that c

297
00:29:40,000 --> 00:29:47,000
of ij is just equal to c of I
minus one, j minus one plus one.

298
00:29:47,000 --> 00:29:54,000
So, it's fairly straightforward
if you think about what's going

299
00:29:54,000 --> 00:29:57,000
on there.
It's not always as

300
00:29:57,000 --> 00:30:04,000
straightforward in some problems
as it is for longest common

301
00:30:04,000 --> 00:30:08,000
subsequence.
The idea is,

302
00:30:08,000 --> 00:30:13,000
so I'm not going to go through
the other cases.

303
00:30:13,000 --> 00:30:16,000
They are similar.
But, in fact,

304
00:30:16,000 --> 00:30:21,000
we've hit on one of the two
hallmarks of dynamic

305
00:30:21,000 --> 00:30:24,000
programming.
So, by hallmarks,

306
00:30:24,000 --> 00:30:30,000
I mean when you see this kind
of structure in a problem,

307
00:30:30,000 --> 00:30:36,000
there's a good chance that
dynamic programming is going to

308
00:30:36,000 --> 00:30:41,000
work as a strategy.
The dynamic programming

309
00:30:41,000 --> 00:30:44,000
hallmark is the following.

310
00:30:44,000 --> 00:30:55,000


311
00:30:55,000 --> 00:31:02,000
This is number one.
And that is the property of

312
00:31:02,000 --> 00:31:09,000
optimal substructure.
OK, what that says is an

313
00:31:09,000 --> 00:31:16,000
optimal solution to a problem,
and by this,

314
00:31:16,000 --> 00:31:21,000
we really mean problem
instance.

315
00:31:21,000 --> 00:31:31,000
But it's tedious to keep saying
problem instance.

316
00:31:31,000 --> 00:31:35,000
A problem is generally,
in computer science,

317
00:31:35,000 --> 00:31:42,000
viewed as having an infinite
number of instances typically,

318
00:31:42,000 --> 00:31:48,000
OK, so sorting is a problem.
A sorting instance is a

319
00:31:48,000 --> 00:31:53,000
particular input.
OK, so we're really talking

320
00:31:53,000 --> 00:31:59,000
about problem instances,
but I'm just going to say

321
00:31:59,000 --> 00:32:04,000
problem, OK?
So, when you have an optimal

322
00:32:04,000 --> 00:32:09,000
solution to a problem,
contains optimal solutions to

323
00:32:09,000 --> 00:32:17,000
subproblems.
OK, and that's worth drawing a

324
00:32:17,000 --> 00:32:22,000
box around because it's so
important.

325
00:32:22,000 --> 00:32:25,000
OK, so here,
for example,

326
00:32:25,000 --> 00:32:33,000
if z is a longest common
subsequence of x and y,

327
00:32:33,000 --> 00:32:55,000
OK, then any prefix of z is a
longest common subsequence of a

328
00:32:55,000 --> 00:33:09,000
prefix of x, and a prefix of y,
OK?

329
00:33:09,000 --> 00:33:12,000
So, this is basically what it
says.

330
00:33:12,000 --> 00:33:16,000
I look at the problem,
and I can see that there is

331
00:33:16,000 --> 00:33:21,000
optimal substructure going on.
OK, in this case,

332
00:33:21,000 --> 00:33:26,000
and the idea is that almost
always, it means that there's a

333
00:33:26,000 --> 00:33:32,000
cut and paste argument you could
do to demonstrate that,

334
00:33:32,000 --> 00:33:36,000
OK, that if the substructure
were not optimal,

335
00:33:36,000 --> 00:33:41,000
then you'd be able to find a
better solution to the overall

336
00:33:41,000 --> 00:33:49,000
problem using cut and paste.
OK, so this theorem,

337
00:33:49,000 --> 00:33:57,000
now, gives us a strategy for
being able to compute longest

338
00:33:57,000 --> 00:34:01,000
comment subsequence.

339
00:34:01,000 --> 00:34:24,000


340
00:34:24,000 --> 00:34:29,000
Here's the code; oh wait.

341
00:34:29,000 --> 00:34:38,000


342
00:34:38,000 --> 00:34:41,000
OK, so going to ignore base
cases in this,

343
00:34:41,000 --> 00:34:42,000
if --

344
00:34:42,000 --> 00:35:44,000


345
00:35:44,000 --> 00:35:54,000
And we will return the value of
the longest common subsequence.

346
00:35:54,000 --> 00:36:02,000
It's basically just
implementing this theorem.

347
00:36:02,000 --> 00:36:06,000
OK, so it's either the longest
comment subsequence if they

348
00:36:06,000 --> 00:36:09,000
match.
It's the longest comment

349
00:36:09,000 --> 00:36:14,000
subsequence of one of the
prefixes where you drop that

350
00:36:14,000 --> 00:36:18,000
character for both strengths and
add one because that's the

351
00:36:18,000 --> 00:36:22,000
matching one.
Or, you drop a character from

352
00:36:22,000 --> 00:36:26,000
x, and it's the longest comment
subsequence of that.

353
00:36:26,000 --> 00:36:31,000
Or you drop a character from y,
whichever one of those is

354
00:36:31,000 --> 00:36:34,000
longer.
That ends up being the longest

355
00:36:34,000 --> 00:36:43,000
comment subsequence.
OK, so what's the worst case

356
00:36:43,000 --> 00:36:52,000
for this program?
What's going to happen in the

357
00:36:52,000 --> 00:37:00,000
worst case?
Which of these two clauses is

358
00:37:00,000 --> 00:37:09,000
going to cause us more headache?
The second clause:

359
00:37:09,000 --> 00:37:12,000
why the second clause?
Yeah, you're doing two LCS

360
00:37:12,000 --> 00:37:16,000
sub-calculations here.
Here, you're only doing one.

361
00:37:16,000 --> 00:37:19,000
Not only that,
but you get to decrement both

362
00:37:19,000 --> 00:37:22,000
indices, whereas here you've
basically got to,

363
00:37:22,000 --> 00:37:26,000
you only get to decrement one
index, and you've got to

364
00:37:26,000 --> 00:37:29,000
calculate two of them.
So that's going to generate the

365
00:37:29,000 --> 00:37:34,000
tree.
So, and the worst case,

366
00:37:34,000 --> 00:37:42,000
x of i is not equal to x of j
for all i and j.

367
00:37:42,000 --> 00:37:52,000
So, let's draw a recursion tree
for this program to sort of get

368
00:37:52,000 --> 00:38:02,000
an understanding as to what is
going on to help us.

369
00:38:02,000 --> 00:38:06,000
And, I'm going to do it with m
equals seven,

370
00:38:06,000 --> 00:38:12,000
and n equals six.
OK, so we start up the top with

371
00:38:12,000 --> 00:38:16,000
my two indices being seven and
six.

372
00:38:16,000 --> 00:38:22,000
And then, in the worst case,
we had to execute these.

373
00:38:22,000 --> 00:38:27,000
So, this is going to end up
being six, six,

374
00:38:27,000 --> 00:38:34,000
and seven, five for indices
after the first call.

375
00:38:34,000 --> 00:38:37,000
And then, this guy is going to
split.

376
00:38:37,000 --> 00:38:44,000
And he's going to produce five,
six here, decrement the first

377
00:38:44,000 --> 00:38:48,000
index, I.
And then, if I keep going down

378
00:38:48,000 --> 00:38:52,000
here, we're going to get four,
six and five,

379
00:38:52,000 --> 00:38:56,000
five.
And these guys keep extending

380
00:38:56,000 --> 00:38:58,000
here.
I get six five,

381
00:38:58,000 --> 00:39:02,000
five five, six four,
OK?

382
00:39:02,000 --> 00:39:08,000
Over here, I'm going to get
decrement the first index,

383
00:39:08,000 --> 00:39:15,000
six five, and I get five five,
six four, and these guys keep

384
00:39:15,000 --> 00:39:17,000
going down.
And over here,

385
00:39:17,000 --> 00:39:22,000
I get seven four.
And then we get six four,

386
00:39:22,000 --> 00:39:27,000
seven three,
and those keep going down.

387
00:39:27,000 --> 00:39:33,000
So, we keep just building this
tree out.

388
00:39:33,000 --> 00:39:38,000
OK, so what's the height of
this tree?

389
00:39:38,000 --> 00:39:46,000
Not of this one for the
particular value of m and n,

390
00:39:46,000 --> 00:39:54,000
but in terms of m and n.
What's the height of this tree?

391
00:39:54,000 --> 00:40:01,000
It's the max of m and n.
You've got the right,

392
00:40:01,000 --> 00:40:07,000
it's theta of the max.
It's not the max.

393
00:40:07,000 --> 00:40:10,000
Max would be,
in this case,

394
00:40:10,000 --> 00:40:14,000
you're saying it has height
seven.

395
00:40:14,000 --> 00:40:18,000
But, I think you can sort of
see, for example,

396
00:40:18,000 --> 00:40:23,000
along a path like this that,
in fact, I've only,

397
00:40:23,000 --> 00:40:28,000
after going three levels,
reduced m plus n,

398
00:40:28,000 --> 00:40:32,000
good, very good,
m plus n.

399
00:40:32,000 --> 00:40:39,000
So, height here is m plus n.
OK, and its binary.

400
00:40:39,000 --> 00:40:45,000
So, the height:
that implies the work is

401
00:40:45,000 --> 00:40:51,000
exponential in m and n.
All that work,

402
00:40:51,000 --> 00:41:01,000
and are we any better off than
the brute force algorithm?

403
00:41:01,000 --> 00:41:05,000
Not really.
And, our technical term for

404
00:41:05,000 --> 00:41:09,000
this is slow.
OK, and we like speed.

405
00:41:09,000 --> 00:41:14,000
OK, we like fast.
OK, but I'm sure that some of

406
00:41:14,000 --> 00:41:20,000
you have observed something
interesting about this tree.

407
00:41:20,000 --> 00:41:25,000
Yeah, there's a lot of repeated
work here.

408
00:41:25,000 --> 00:41:31,000
Right, there's a lot of
repeated work.

409
00:41:31,000 --> 00:41:34,000
In particular,
this whole subtree,

410
00:41:34,000 --> 00:41:40,000
and this whole subtree,
OK, they are the same.

411
00:41:40,000 --> 00:41:46,000
That's the same subtree,
the same subproblem that you

412
00:41:46,000 --> 00:41:51,000
are solving.
OK, you can even see over here,

413
00:41:51,000 --> 00:41:58,000
there is even similarity
between this whole subtree and

414
00:41:58,000 --> 00:42:03,000
this whole subtree.
OK, so there's lots of repeated

415
00:42:03,000 --> 00:42:08,000
work.
OK, and one thing is,

416
00:42:08,000 --> 00:42:13,000
if you want to do things fast,
don't keep doing the same

417
00:42:13,000 --> 00:42:17,000
thing.
OK, don't keep doing the same

418
00:42:17,000 --> 00:42:21,000
thing.
When you find you are repeating

419
00:42:21,000 --> 00:42:25,000
something, figure out a way of
not doing it.

420
00:42:25,000 --> 00:42:30,000
So, that brings up our second
hallmark for dynamic

421
00:42:30,000 --> 00:42:33,000
programming.

422
00:42:33,000 --> 00:42:50,000


423
00:42:50,000 --> 00:43:07,000
And that's a property called
overlapping subproblems,

424
00:43:07,000 --> 00:43:19,000
OK?
OK, recursive solution contains

425
00:43:19,000 --> 00:43:33,000
many, excuse me,
contains a small number of

426
00:43:33,000 --> 00:43:50,000
distinct subproblems repeated
many times.

427
00:43:50,000 --> 00:43:54,000
And once again,
this is important enough to put

428
00:43:54,000 --> 00:43:58,000
a box around.
I don't put boxes around too

429
00:43:58,000 --> 00:44:01,000
many things.
Maybe I should put our boxes

430
00:44:01,000 --> 00:44:05,000
around things.
This is definitely one to put a

431
00:44:05,000 --> 00:44:08,000
box around, OK?
So, for example,

432
00:44:08,000 --> 00:44:12,000
so here we have a recursive
solution.

433
00:44:12,000 --> 00:44:15,000
This tree is exponential in
size.

434
00:44:15,000 --> 00:44:19,000
It's two to the m plus n in
height, in size,

435
00:44:19,000 --> 00:44:24,000
in the total number of problems
if I actually implemented like

436
00:44:24,000 --> 00:44:27,000
that.
But how many distinct

437
00:44:27,000 --> 00:44:33,000
subproblems are there?
m times n, OK?

438
00:44:33,000 --> 00:44:42,000
So, the longest comment
subsequence, the subproblem

439
00:44:42,000 --> 00:44:49,000
space contains m times n,
distinct subproblems.

440
00:44:49,000 --> 00:45:00,000
OK, and then this is a small
number compared with two to the

441
00:45:00,000 --> 00:45:07,000
m plus n, or two to the n,
or two to the m,

442
00:45:07,000 --> 00:45:13,000
or whatever.
OK, this is small,

443
00:45:13,000 --> 00:45:19,000
OK, because for each
subproblem, it's characterized

444
00:45:19,000 --> 00:45:24,000
by an I and a j.
An I goes from one to m,

445
00:45:24,000 --> 00:45:27,000
and j goes from one to n,
OK?

446
00:45:27,000 --> 00:45:34,000
There aren't that many
different subproblems.

447
00:45:34,000 --> 00:45:36,000
It's just the product of the
two.

448
00:45:36,000 --> 00:45:41,000
So, here's an improved
algorithm, which is often a good

449
00:45:41,000 --> 00:45:45,000
way to solve it.
It's an algorithm called a

450
00:45:45,000 --> 00:45:48,000
memo-ization algorithm.

451
00:45:48,000 --> 00:45:56,000


452
00:45:56,000 --> 00:46:02,000
And, this is memo-ization,
not memorization because what

453
00:46:02,000 --> 00:46:09,000
you're going to do is make a
little memo whenever you solve a

454
00:46:09,000 --> 00:46:14,000
subproblem.
Make a little memo that says I

455
00:46:14,000 --> 00:46:19,000
solved this already.
And if ever you are asked for

456
00:46:19,000 --> 00:46:25,000
it rather than recalculating it,
say, oh, I see that.

457
00:46:25,000 --> 00:46:30,000
I did that before.
Here's the answer,

458
00:46:30,000 --> 00:46:32,000
OK?
So, here's the code.

459
00:46:32,000 --> 00:46:40,000
It's very similar to that code.
So, it basically keeps a table

460
00:46:40,000 --> 00:46:44,000
around of c[i,j].
It says, what we do is we

461
00:46:44,000 --> 00:46:47,000
check.
If the entry for c[i,j] is nil,

462
00:46:47,000 --> 00:46:51,000
we haven't computed it,
then we compute it.

463
00:46:51,000 --> 00:46:55,000
And, how do we compute it?
Just the same way we did

464
00:46:55,000 --> 00:46:57,000
before.

465
00:46:57,000 --> 00:47:34,000


466
00:47:34,000 --> 00:47:45,000
OK, so this whole part here,
OK, is exactly what we have had

467
00:47:45,000 --> 00:47:51,000
before.
It's the same as before.

468
00:47:51,000 --> 00:47:59,000
And then, we just return
c[i,j].

469
00:47:59,000 --> 00:48:03,000
If we don't bother to keep
recalculating,

470
00:48:03,000 --> 00:48:07,000
OK, so if it's nil,
we calculate it.

471
00:48:07,000 --> 00:48:12,000
Otherwise, we just return it.
It's not calculated,

472
00:48:12,000 --> 00:48:18,000
calculate and return it.
Otherwise, just return it:

473
00:48:18,000 --> 00:48:21,000
OK, pretty straightforward
code.

474
00:48:21,000 --> 00:48:23,000
OK.

475
00:48:23,000 --> 00:48:33,000


476
00:48:33,000 --> 00:48:38,000
OK, now the tricky thing is how
much time does it take to

477
00:48:38,000 --> 00:48:40,000
execute this?

478
00:48:40,000 --> 00:48:58,000


479
00:48:58,000 --> 00:49:04,000
This takes a little bit of
thinking.

480
00:49:04,000 --> 00:49:10,000
Yeah?
Yeah, it takes order MN.

481
00:49:10,000 --> 00:49:18,000
OK, why is that?
Yeah, but I have to look up

482
00:49:18,000 --> 00:49:25,000
c[i,j].
I might call c[i,j] a bunch of

483
00:49:25,000 --> 00:49:29,000
times.
When I'm doing this,

484
00:49:29,000 --> 00:49:38,000
I'm still calling it
recursively.

485
00:49:38,000 --> 00:49:43,000
Yeah, so you have to,
so each recursive call is going

486
00:49:43,000 --> 00:49:50,000
to look at, and the worst-case,
say, is going to look at the

487
00:49:50,000 --> 00:49:55,000
max of these two things.
Well, this is going to involve

488
00:49:55,000 --> 00:50:00,000
a recursive call,
and a lookup.

489
00:50:00,000 --> 00:50:05,000
So, this might take a fair
amount of effort to calculate.

490
00:50:05,000 --> 00:50:09,000
I mean, you're right,
and your intuition is right.

491
00:50:09,000 --> 00:50:13,000
Let's see if we can get a more
precise argument,

492
00:50:13,000 --> 00:50:17,000
why this is taking order m
times n.

493
00:50:17,000 --> 00:50:21,000
What's going on here?
Because not every time I call

494
00:50:21,000 --> 00:50:27,000
this is it going to just take me
a constant amount of work to do

495
00:50:27,000 --> 00:50:30,000
this.
Sometimes it's going to take me

496
00:50:30,000 --> 00:50:34,000
a lot of work.
Sometimes I get lucky,

497
00:50:34,000 --> 00:50:41,000
and I return it.
So, your intuition is dead on.

498
00:50:41,000 --> 00:50:47,000
It's dead on.
We just need a little bit more

499
00:50:47,000 --> 00:50:55,000
articulate explanation,
so that everybody is on board.

500
00:50:55,000 --> 00:51:01,000
Try again?
Good, at most three times,

501
00:51:01,000 --> 00:51:04,000
yeah.
OK, so that's one way to look

502
00:51:04,000 --> 00:51:05,000
at it.
Yeah.

503
00:51:05,000 --> 00:51:09,000
There is another way to look at
it that's kind of what you are

504
00:51:09,000 --> 00:51:12,000
expressing there is an
amortized, a bookkeeping,

505
00:51:12,000 --> 00:51:15,000
way of looking at this.
What's the amortized cost?

506
00:51:15,000 --> 00:51:18,000
You could say what the
amortized cost of calculating

507
00:51:18,000 --> 00:51:21,000
one of these,
where basically whenever I call

508
00:51:21,000 --> 00:51:24,000
it, I'm going to charge a
constant amount for looking up.

509
00:51:24,000 --> 00:51:28,000
And so, I could get to look up
whatever is in here to call the

510
00:51:28,000 --> 00:51:31,000
things.
But if it, in fact,

511
00:51:31,000 --> 00:51:35,000
so in some sense,
this charge here,

512
00:51:35,000 --> 00:51:41,000
of calling it and returning it,
etc., I charged that to my

513
00:51:41,000 --> 00:51:44,000
caller.
OK, so I charged these lines

514
00:51:44,000 --> 00:51:50,000
and this line to the caller.
And I charge the rest of these

515
00:51:50,000 --> 00:51:55,000
lines to the c[i,j] element.
And then, the point is that

516
00:51:55,000 --> 00:52:02,000
every caller basically only ends
up being charged for a constant

517
00:52:02,000 --> 00:52:07,000
amount of stuff.
OK, to calculate one c[i,j],

518
00:52:07,000 --> 00:52:11,000
it's only an amortized constant
amount of stuff that I'm

519
00:52:11,000 --> 00:52:16,000
charging to that calculation of
i and j, that calculation of i

520
00:52:16,000 --> 00:52:19,000
and j.
OK, so you can view it in terms

521
00:52:19,000 --> 00:52:23,000
of amortized analysis doing a
bookkeeping argument that just

522
00:52:23,000 --> 00:52:27,000
says, let me charge enough to
calculate my own,

523
00:52:27,000 --> 00:52:32,000
do all my own local things plus
enough to look up the value in

524
00:52:32,000 --> 00:52:36,000
the next level and get it
returned.

525
00:52:36,000 --> 00:52:40,000
OK, and then if it has to go
off and calculate,

526
00:52:40,000 --> 00:52:46,000
well, that's OK because that's
all been charged to a different

527
00:52:46,000 --> 00:52:50,000
ij at that point.
So, every cell only costs me a

528
00:52:50,000 --> 00:52:56,000
constant amount of time that
order MN cells total of order

529
00:52:56,000 --> 00:53:00,000
MN.
OK: constant work per entry.

530
00:53:00,000 --> 00:53:04,000
OK, and you can sort of use an
amortized analysis to argue

531
00:53:04,000 --> 00:53:07,000
that.
How much space does it take?

532
00:53:07,000 --> 00:53:12,000
We haven't usually looked at
space, but here we are going to

533
00:53:12,000 --> 00:53:15,000
start looking at space.
That turns out,

534
00:53:15,000 --> 00:53:20,000
for some of these algorithms,
to be really important.

535
00:53:20,000 --> 00:53:23,000
How much space do I need,
storage space?

536
00:53:23,000 --> 00:53:28,000
Yeah, also m times n,
OK, to store the c[i,j] table.

537
00:53:28,000 --> 00:53:30,000
OK, the rest,
storing x and y,

538
00:53:30,000 --> 00:53:35,000
OK, that's just m plus n.
So, that's negligible,

539
00:53:35,000 --> 00:53:37,000
but mostly I need the space m
times n.

540
00:53:37,000 --> 00:53:41,000
So, this memo-ization type
algorithm is a really good

541
00:53:41,000 --> 00:53:44,000
strategy in programming for many
things where,

542
00:53:44,000 --> 00:53:48,000
when you have the same
parameters, you're going to get

543
00:53:48,000 --> 00:53:51,000
the same results.
It doesn't work in programs

544
00:53:51,000 --> 00:53:53,000
where you have a side effect,
necessarily,

545
00:53:53,000 --> 00:53:57,000
that is, when the calculation
for a given set of parameters

546
00:53:57,000 --> 00:54:03,000
might be different on each call.
But for something which is

547
00:54:03,000 --> 00:54:08,000
essentially like a functional
programming type of environment,

548
00:54:08,000 --> 00:54:13,000
then if you've calculated it
once, you can look it up.

549
00:54:13,000 --> 00:54:19,000
And, so this is very helpful.
But, it takes a fair amount of

550
00:54:19,000 --> 00:54:24,000
space, and it also doesn't
proceed in a very orderly way.

551
00:54:24,000 --> 00:54:29,000
So, there is another strategy
for doing exactly the same

552
00:54:29,000 --> 00:54:34,000
calculation in a bottom-up way.
And that's what we call dynamic

553
00:54:34,000 --> 00:54:42,000
programming.
OK, the idea is to compute the

554
00:54:42,000 --> 00:54:49,000
table bottom-up.
I think I'm going to get rid

555
00:54:49,000 --> 00:54:56,000
of, I think what we'll do is
we'll just use,

556
00:54:56,000 --> 00:55:07,000
actually I think what I'm going
to do is use this board.

557
00:55:07,000 --> 00:55:33,000


558
00:55:33,000 --> 00:55:38,000
OK, so here's the idea.
What we're going to do is look

559
00:55:38,000 --> 00:55:45,000
at the c[i,j] table and realize
that there's actually an orderly

560
00:55:45,000 --> 00:55:51,000
way of filling in the table.
This is sort of a top-down with

561
00:55:51,000 --> 00:55:55,000
memo-ization.
OK, but there's actually a way

562
00:55:55,000 --> 00:56:00,000
we can do it bottom up.
So, here's the idea.

563
00:56:00,000 --> 00:56:07,000
So, let's make our table.
OK, so there's x.

564
00:56:07,000 --> 00:56:18,000
And then, there's y.
And, I'm going to initialize

565
00:56:18,000 --> 00:56:28,000
the empty string.
I didn't cover the base cases

566
00:56:28,000 --> 00:56:39,000
for c[i,j], but c of zero
meaning a prefix with no

567
00:56:39,000 --> 00:56:45,000
elements in it.
The prefix of that with

568
00:56:45,000 --> 00:56:48,000
anything else,
the length is zero.

569
00:56:48,000 --> 00:56:53,000
OK, so that's basically how I'm
going to bound the borders here.

570
00:56:53,000 --> 00:56:57,000
And now, what I can do is just
use my formula,

571
00:56:57,000 --> 00:57:00,000
which I've conveniently erased
up there, OK,

572
00:57:00,000 --> 00:57:04,000
to compute what is the longest
common subsequence,

573
00:57:04,000 --> 00:57:09,000
length of the longest comment
subsequence from this character

574
00:57:09,000 --> 00:57:15,000
in y, and this character in x up
to this character.

575
00:57:15,000 --> 00:57:19,000
So here, for example,
they don't match.

576
00:57:19,000 --> 00:57:24,000
So, it's the maximum of these
two values.

577
00:57:24,000 --> 00:57:29,000
Here, they do match.
OK, so it says it's one plus

578
00:57:29,000 --> 00:57:34,000
the value here.
And, I'm going to draw a line.

579
00:57:34,000 --> 00:57:38,000
Whenever I'm going to get a
match, I'm going to draw a line

580
00:57:38,000 --> 00:57:41,000
like that, indicating that I had
that first case,

581
00:57:41,000 --> 00:57:44,000
the case where they had a good
match.

582
00:57:44,000 --> 00:57:47,000
And so, all I'm doing is
applying that recursive formula

583
00:57:47,000 --> 00:57:52,000
from the theorem that we proved.
So here, it's basically they

584
00:57:52,000 --> 00:57:54,000
don't match.
So, it's the maximum of those

585
00:57:54,000 --> 00:57:56,000
two.
Here, they match.

586
00:57:56,000 --> 00:58:01,000
So, it's one plus that guy.
Here, they don't match.

587
00:58:01,000 --> 00:58:06,000
So, it's basically the maximum
of these two.

588
00:58:06,000 --> 00:58:11,000
Here, they don't match.
So it's the maximum.

589
00:58:11,000 --> 00:58:17,000
So, it's one plus that guy.
So, everybody understand how I

590
00:58:17,000 --> 00:58:23,000
filled out that first row?
OK, well that you guys can

591
00:58:23,000 --> 00:58:27,000
help.
OK, so this one is what?

592
00:58:27,000 --> 00:58:32,000
Just call it out.
Zero, good.

593
00:58:32,000 --> 00:58:41,000
One, because it's the maximum,
one, two, right.

594
00:58:41,000 --> 00:58:47,000
This one, now,
gets from there,

595
00:58:47,000 --> 00:58:52,000
two, two.
OK, here, zero,

596
00:58:52,000 --> 00:59:03,000
one, because it's the maximum
of those two.

597
00:59:03,000 --> 00:59:15,000
Two, two, two,
good.

598
00:59:15,000 --> 00:59:34,000
One, one, two,
two, two, three,

599
00:59:34,000 --> 00:59:48,000
three.
One, two, three,

600
00:59:48,000 --> 01:00:00,250
get that line,
three, four,

601
01:00:00,250 --> 01:00:05,974
OK.
One there, three,

602
01:00:05,974 --> 01:00:10,000
three, four,
good, four.

603
01:00:10,000 --> 01:00:14,199
OK, and our answer:
four.

604
01:00:14,199 --> 01:00:23,125
So this is blindingly fast code
if you code this up,

605
01:00:23,125 --> 01:00:33,275
OK, because it gets to use the
fact that modern machines in

606
01:00:33,275 --> 01:00:45,000
particular do very well on
regular strides through memory.

607
01:00:45,000 --> 01:00:50,012
So, if you're just plowing
through memory across like this,

608
01:00:50,012 --> 01:00:55,024
OK, and your two-dimensional
array is stored in that order,

609
01:00:55,024 --> 01:00:58,308
which it is,
otherwise you go this way,

610
01:00:58,308 --> 01:01:02,802
stored in that order.
This can really fly in terms of

611
01:01:02,802 --> 01:01:11,948
the speed of the calculation.
So, how much time did it take

612
01:01:11,948 --> 01:01:17,897
us to do this?
Yeah, order MN,

613
01:01:17,897 --> 01:01:20,769
theta MN.
Yeah?

614
01:01:20,769 --> 01:01:30,000
We'll talk about space in just
a minute.

615
01:01:30,000 --> 01:01:33,875
OK, so hold that question.
Good question,

616
01:01:33,875 --> 01:01:36,491
good question,
already, wow,

617
01:01:36,491 --> 01:01:40,657
good, OK, how do I now figure
out, remember,

618
01:01:40,657 --> 01:01:46,179
we had the simplification.
We were going to just calculate

619
01:01:46,179 --> 01:01:49,764
the length.
OK, it turns out I can now

620
01:01:49,764 --> 01:01:54,415
figure out a particular sequence
that matches it.

621
01:01:54,415 --> 01:01:58,000
And basically,
I do that.

622
01:01:58,000 --> 01:02:04,932
I can reconstruct the longest
common subsequence by tracing

623
01:02:04,932 --> 01:02:09,474
backwards.
So essentially I start here.

624
01:02:09,474 --> 01:02:15,928
Here I have a choice because
this one was dependent on,

625
01:02:15,928 --> 01:02:22,980
since it doesn't have a bar
here, it was dependent on one of

626
01:02:22,980 --> 01:02:28,000
these two.
So, let me go this way.

627
01:02:28,000 --> 01:02:33,444
OK, and now I have a diagonal
element here.

628
01:02:33,444 --> 01:02:41,222
So what I'll do is simply mark
the character that appeared in

629
01:02:41,222 --> 01:02:45,370
those positions as I go this
way.

630
01:02:45,370 --> 01:02:51,203
I have three here.
And now, let me keep going,

631
01:02:51,203 --> 01:02:56,129
three here, and now I have
another one.

632
01:02:56,129 --> 01:03:03,000
So that means this character
gets selected.

633
01:03:03,000 --> 01:03:08,632
And then I go up to here,
OK, and then up to here.

634
01:03:08,632 --> 01:03:15,643
And now I go diagonally again,
which means that this character

635
01:03:15,643 --> 01:03:18,977
is selected.
And I go to here,

636
01:03:18,977 --> 01:03:24,724
and then I go here.
And then, I go up here and this

637
01:03:24,724 --> 01:03:30,471
character is selected.
So here is my longest common

638
01:03:30,471 --> 01:03:35,098
subsequence.
And this was just one path

639
01:03:35,098 --> 01:03:37,843
back.
I could have gone a path like

640
01:03:37,843 --> 01:03:42,203
this and gotten a different
longest common subsequence.

641
01:03:42,203 --> 01:03:45,997
OK, so that simplification of
just saying, look,

642
01:03:45,997 --> 01:03:49,468
let me just run backwards and
figure it out,

643
01:03:49,468 --> 01:03:53,989
that's actually pretty good
because it means that by just

644
01:03:53,989 --> 01:03:58,026
calculating the value,
then figuring out these back

645
01:03:58,026 --> 01:04:04,000
pointers to let me reconstruct
it is a fairly simple process.

646
01:04:04,000 --> 01:04:10,075
OK, if I had to think about
that to begin with,

647
01:04:10,075 --> 01:04:14,962
it would have been a much
bigger mess.

648
01:04:14,962 --> 01:04:19,452
OK, so the space,
I just mentioned,

649
01:04:19,452 --> 01:04:25,264
was order MN because we still
need the table.

650
01:04:25,264 --> 01:04:32,000
So, you can actually do the min
of m and n.

651
01:04:32,000 --> 01:04:37,970
OK, to get to your question,
how do you do the min of m and

652
01:04:37,970 --> 01:04:41,367
n?
Diagonal stripes won't give you

653
01:04:41,367 --> 01:04:45,897
min of m and n.
That'll give you the sum of m

654
01:04:45,897 --> 01:04:48,676
and n.
So, going in stripes,

655
01:04:48,676 --> 01:04:53,308
maybe I'm not quite sure I know
what you mean.

656
01:04:53,308 --> 01:04:58,250
So, you're saying,
so what's the order I would do

657
01:04:58,250 --> 01:05:01,661
here?
So, I would start.

658
01:05:01,661 --> 01:05:06,461
I would do this one first.
Then which one would I do?

659
01:05:06,461 --> 01:05:10,246
This one and this one?
And then, this one,

660
01:05:10,246 --> 01:05:12,923
this one, this one,
like this?

661
01:05:12,923 --> 01:05:18,000
That's a perfectly good order.
OK, and so you're saying,

662
01:05:18,000 --> 01:05:22,800
then, so I'm keeping the
diagonal there all the time.

663
01:05:22,800 --> 01:05:28,615
So, you're saying the length of
the diagonal is the min of m and

664
01:05:28,615 --> 01:05:31,633
n?
I think that's right.

665
01:05:31,633 --> 01:05:36,068
OK, there is another way you
can do it that's a little bit

666
01:05:36,068 --> 01:05:39,881
more straightforward,
which is you compare m to n.

667
01:05:39,881 --> 01:05:42,993
Whichever is smaller,
well, first of all,

668
01:05:42,993 --> 01:05:45,871
let's just do this existing
algorithm.

669
01:05:45,871 --> 01:05:50,228
If I just simply did row by
row, I don't need more than a

670
01:05:50,228 --> 01:05:53,418
previous row.
OK, I just need one row at a

671
01:05:53,418 --> 01:05:56,141
time.
So, I can go ahead and compute

672
01:05:56,141 --> 01:06:00,421
just one row because once I
computed the succeeding row,

673
01:06:00,421 --> 01:06:04,910
the first row is unimportant.
And in fact,

674
01:06:04,910 --> 01:06:07,263
I don't even need the whole
row.

675
01:06:07,263 --> 01:06:10,754
All I need is just the current
row that I'm on,

676
01:06:10,754 --> 01:06:14,093
plus one or two elements of the
previous row,

677
01:06:14,093 --> 01:06:16,522
plus the end of the previous
row.

678
01:06:16,522 --> 01:06:20,848
So, I use a prefix of this row,
and an extra two elements,

679
01:06:20,848 --> 01:06:24,263
and the suffix of this row.
So, it's actually,

680
01:06:24,263 --> 01:06:28,058
you can do it with one row,
plus order one element.

681
01:06:28,058 --> 01:06:32,535
And then, I could do it either
running vertically or running

682
01:06:32,535 --> 01:06:35,495
horizontally,
whichever one gives me the

683
01:06:35,495 --> 01:06:40,303
smaller space.
OK, and it might be that your

684
01:06:40,303 --> 01:06:43,084
diagonal trick would work there
too.

685
01:06:43,084 --> 01:06:45,785
I'd have to think about that.
Yeah?

686
01:06:45,785 --> 01:06:50,392
Ooh, that's a good question.
So, you can do the calculation

687
01:06:50,392 --> 01:06:53,570
of the length,
and run row plus order one

688
01:06:53,570 --> 01:06:57,415
elements.
OK, and our exercise,

689
01:06:57,415 --> 01:07:04,203
and this is a hard exercise,
OK, so that a good one to do is

690
01:07:04,203 --> 01:07:11,221
to do small space and allow you
to reconstruct the LCS because

691
01:07:11,221 --> 01:07:18,469
the nave way that we were just
doing it, it's not clear how you

692
01:07:18,469 --> 01:07:24,336
would go backwards from that
because you've lost the

693
01:07:24,336 --> 01:07:29,168
information.
OK, so this is actually a very

694
01:07:29,168 --> 01:07:37,182
interesting and tricky problem.
And, it turns out it succumbs

695
01:07:37,182 --> 01:07:43,329
of all things to divide and
conquer, OK, rather than some

696
01:07:43,329 --> 01:07:47,060
more straightforward tabular
thing.

697
01:07:47,060 --> 01:07:51,231
OK: so very good practice,
for example,

698
01:07:51,231 --> 01:07:57,268
for the upcoming take home
quiz, OK, which is all design

699
01:07:57,268 --> 01:08:03,493
and cleverness type quiz.
OK, so this is a good one for

700
01:08:03,493 --> 01:08:07,191
people to take on.
So, this is basically the

701
01:08:07,191 --> 01:08:11,319
tabular method that's called
dynamic programming.

702
01:08:11,319 --> 01:08:16,479
OK, memo-ization is not dynamic
programming, even though it's

703
01:08:16,479 --> 01:08:18,714
related.
It's memo-ization.

704
01:08:18,714 --> 01:08:23,788
And, we're going to see a whole
bunch of other problems that

705
01:08:23,788 --> 01:08:27,314
succumb to dynamic programming
approaches.

706
01:08:27,314 --> 01:08:31,098
It's a very cool method,
and on the homework,

707
01:08:31,098 --> 01:08:36,000
so let me just mention the
homework again.

708
01:08:36,000 --> 01:08:38,216
On the homework,
we're going to look at a

709
01:08:38,216 --> 01:08:40,434
problem called the edit distance
problem.

710
01:08:40,434 --> 01:08:42,763
Edit distance is you are given
two strings.

711
01:08:42,763 --> 01:08:46,256
And you can imagine that you're
typing in a keyboard with one of

712
01:08:46,256 --> 01:08:48,862
the strings there.
And what you have to do is by

713
01:08:48,862 --> 01:08:50,303
doing inserts,
and deletes,

714
01:08:50,303 --> 01:08:52,631
and replaces,
and moving the cursor around,

715
01:08:52,631 --> 01:08:55,182
you've got to transform one
string to the next.

716
01:08:55,182 --> 01:08:57,399
And, each of those operations
has a cost.

717
01:08:57,399 --> 01:09:00,671
And your job is to minimize the
cost of transforming the one

718
01:09:00,671 --> 01:09:05,565
string into the other.
This actually turns out also to

719
01:09:05,565 --> 01:09:09,537
be useful for computational
biology applications.

720
01:09:09,537 --> 01:09:12,600
And, in fact,
there have been editors,

721
01:09:12,600 --> 01:09:14,917
screen editors,
text editors,

722
01:09:14,917 --> 01:09:19,881
that implement algorithms of
this nature in order to minimize

723
01:09:19,881 --> 01:09:24,931
the number of characters that
have to be sent as IO in and out

724
01:09:24,931 --> 01:09:28,568
of the system.
So, the warning is,

725
01:09:28,568 --> 01:09:33,274
you better get going on your
programming on problem one on

726
01:09:33,274 --> 01:09:37,816
the homework today if at all
possible because whenever I

727
01:09:37,816 --> 01:09:41,862
assign programming,
since we don't do that as sort

728
01:09:41,862 --> 01:09:45,660
of a routine thing,
I'm just concerned for some

729
01:09:45,660 --> 01:09:50,283
people that there will not be
able to get things like the

730
01:09:50,283 --> 01:09:53,422
input and output to work,
and so forth.

731
01:09:53,422 --> 01:09:57,550
We have example problems,
and such, on the website.

732
01:09:57,550 --> 01:10:00,853
And we also have,
you can write it in any

733
01:10:00,853 --> 01:10:03,743
language you want,
including Matlab,

734
01:10:03,743 --> 01:10:08,697
Python, whatever your favorite,
the solutions will be written

735
01:10:08,697 --> 01:10:14,425
in Java and Python.
OK, so the fastest solutions

736
01:10:14,425 --> 01:10:19,188
are likely to be written in c.
OK, you can also do it in

737
01:10:19,188 --> 01:10:21,960
assembly language if you care
to.

738
01:10:21,960 --> 01:10:24,905
You laugh.
I used to be in assembly

739
01:10:24,905 --> 01:10:28,716
language programmer back in the
days of yore.

740
01:10:28,716 --> 01:10:34,086
OK, so I do encourage people to
get started on this because let

741
01:10:34,086 --> 01:10:39,370
me mention, the other thing is
that this particular problem on

742
01:10:39,370 --> 01:10:45,000
this problem set is an
absolutely mandatory problem.

743
01:10:45,000 --> 01:10:49,662
OK, all the problems are
mandatory, but as you know you

744
01:10:49,662 --> 01:10:54,583
can skip them and it doesn't
hurt you too much if you only

745
01:10:54,583 --> 01:10:57,605
skip one or two.
This one, you skip,

746
01:10:57,605 --> 01:11:00,367
hurts big time:
one letter grade.

747
01:11:00,367 --> 01:11:03,000
It must be done.